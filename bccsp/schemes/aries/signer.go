/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package aries

import (
	"crypto/ecdsa"
	"fmt"

	"github.com/IBM/idemix/bccsp/handlers"
	bccsp "github.com/IBM/idemix/bccsp/schemes"
	math "github.com/IBM/mathlib"
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/aries-framework-go/component/kmscrypto/crypto/primitive/bbs12381g2pub"
)

type Signer struct {
	Curve *math.Curve
}

// Sign creates a new idemix signature
func (s *Signer) Sign(
	credBytes []byte,
	sk *math.Zr,
	Nym *math.G1,
	RNym *math.Zr,
	key handlers.IssuerPublicKey,
	attributes []bccsp.IdemixAttribute,
	msg []byte,
	rhIndex, eidIndex int,
	cri []byte,
	sigType bccsp.SignatureType,
	metadata *bccsp.IdemixSignerMetadata,
) ([]byte, *bccsp.IdemixSignerMetadata, error) {
	ipk, ok := key.(*IssuerPublicKey)
	if !ok {
		return nil, nil, fmt.Errorf("invalid issuer public key, expected *IssuerPublicKey, got [%T]", ipk)
	}

	// TODO:
	// 1) revocation
	_ = cri
	// 2) rhIndex
	_ = rhIndex
	// 3) eidIndex
	_ = eidIndex
	// 4) sigType
	_ = sigType
	// 5) metadata
	_ = metadata

	// Nym is h_0^{RNym} \cdot h_1^{sk}
	// I also have to prove that sk in Nym is the same as the first attribute
	_ = RNym
	_ = sk
	_ = Nym

	pkbytes, err := ipk.Bytes()
	if err != nil {
		return nil, nil, fmt.Errorf("ipk.Bytes failed [%w]", err)
	}

	credential := &Credential{}
	err = proto.Unmarshal(credBytes, credential)
	if err != nil {
		return nil, nil, fmt.Errorf("proto.Unmarshal failed [%w]", err)
	}

	bls := bbs12381g2pub.New()
	proofBytes, err := bls.DeriveProofZr(credential.toSignatureMessage(sk, s.Curve), credential.Cred, msg, pkbytes, revealedAttributesIndex(attributes))
	if err != nil {
		return nil, nil, fmt.Errorf("bls.DeriveProofZr failed [%w]", err)
	}

	return proofBytes, nil, nil
}

// Verify verifies an idemix signature.
func (s *Signer) Verify(
	key handlers.IssuerPublicKey,
	signature, msg []byte,
	attributes []bccsp.IdemixAttribute,
	rhIndex, eidIndex int,
	revocationPublicKey *ecdsa.PublicKey,
	epoch int,
	verType bccsp.VerificationType,
	meta *bccsp.IdemixSignerMetadata,
) error {
	ipk, ok := key.(*IssuerPublicKey)
	if !ok {
		return fmt.Errorf("invalid issuer public key, expected *IssuerPublicKey, got [%T]", ipk)
	}

	// TODO:
	// 1) revocation
	_ = revocationPublicKey
	_ = epoch
	// 2) rhIndex
	_ = rhIndex
	// 3) eidIndex
	_ = eidIndex
	// 4) verType
	_ = verType
	// 5) meta
	_ = meta

	pkbytes, err := ipk.Bytes()
	if err != nil {
		return fmt.Errorf("ipk.Bytes failed [%w]", err)
	}

	bls := bbs12381g2pub.New()

	return bls.VerifyProofFr(attributesToSignatureMessage(nil, attributes, s.Curve), signature, msg, pkbytes)
}

// AuditNymEid permits the auditing of the nym eid generated by a signer
func (s *Signer) AuditNymEid(
	ipk handlers.IssuerPublicKey,
	eidIndex int,
	signature []byte,
	enrollmentID string,
	RNymEid *math.Zr,
	verType bccsp.AuditVerificationType,
) error {
	return nil
}

// AuditNymRh permits the auditing of the nym rh generated by a signer
func (s *Signer) AuditNymRh(
	ipk handlers.IssuerPublicKey,
	rhIndex int,
	signature []byte,
	revocationHandle string,
	RNymRh *math.Zr,
	verType bccsp.AuditVerificationType,
) error {
	return nil
}
